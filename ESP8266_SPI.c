/*************************************************
* ESP8266 HARDWARE SPI (HSPI) LIBRARY
*
* OCTOBER 26 2016
* ANKIT BHATNAGAR
* ANKIT.BHATNAGARINDIA@GMAIL.COM
* ***********************************************/


#include "ESP8266_SPI.h"

void ESP8266_SPI_init_pins(void)
{
	//INITIALIZE THE GPIO PINS USED FOR SPI
	//GPIO12 - MTDI - HSPI MISO
	//GPIO13 - MTCK - HSPI MOSI
	//GPIO14 - MTMS - HSPI CLK
	//GPIO15 - MTDO - HSPI CS

	WRITE_PERI_REG(PERIPHS_IO_MUX, 0x105); //Set bit 9 if 80MHz sysclock required
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTDI_U, 2);
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTCK_U, 2);
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_MTMS_U, 2);
	PIN_FUNC_SELECT(PERIPHS_IO_MUX_GPIO4_U, FUNC_GPIO4);

	//SET CS LINE HIGH
	ESP8266_SPI_CS_HIGH;
}

void ESP8266_SPI_set_params(void)
{
	//SET SPI1 (HSPI) PARAMETERS

	CLEAR_PERI_REG_MASK(SPI_USER(HSPI), SPI_FLASH_MODE);
		CLEAR_PERI_REG_MASK(SPI_USER(HSPI), SPI_USR_MISO);

	//SET GENERAL BEHAVIOR AND DATA FORMAT AND CS LINE BEHAVIOR
	SET_PERI_REG_MASK(SPI_USER(HSPI), SPI_USR_ADDR | SPI_USR_MOSI);


	//SET CPOL=0 & CPHA=0
	CLEAR_PERI_REG_MASK(SPI_USER(HSPI), SPI_IDLE_EDGE);
	CLEAR_PERI_REG_MASK(SPI_USER(HSPI), SPI_CK_OUT_EDGE);

	//SET SPI CLOCK
	uint16_t prediv = 9;
	uint8_t cntdiv = 3;
	WRITE_PERI_REG(SPI_CLOCK(HSPI), (((prediv-1)&SPI_CLKDIV_PRE)<<SPI_CLKDIV_PRE_S)|
									(((cntdiv-1)&SPI_CLKCNT_N)<<SPI_CLKCNT_N_S)|
									(((cntdiv>>1)&SPI_CLKCNT_H)<<SPI_CLKCNT_H_S)|
									((0&SPI_CLKCNT_L)<<SPI_CLKCNT_L_S));

	//SET DATA ORDER (MSB FIRST)
	SET_PERI_REG_MASK(SPI_USER(HSPI), SPI_WR_BYTE_ORDER);

	//SET SPI DATA LENGTHS
	//FOR MAX7221 ADDRESS(8 : UPPER 4 BITS IGNORED) + DATA(8)
	WRITE_PERI_REG(SPI_USER(HSPI), ((7&SPI_USR_MOSI_BITLEN)<<SPI_USR_MOSI_BITLEN_S) |
									((7&SPI_USR_ADDR_BITLEN)<<SPI_USR_ADDR_BITLEN_S));
}

void ESP8266_SPI_send(uint32_t address, uint32_t data)
{
	//SEND SPI DATA OUT

	//disable MOSI, MISO, ADDR, COMMAND, DUMMY in case previously set.
	CLEAR_PERI_REG_MASK(SPI_USER(HSPI), SPI_USR_MOSI|SPI_USR_MISO|SPI_USR_COMMAND|SPI_USR_ADDR|SPI_USR_DUMMY);

	//SETUP 8 BIT ADDRESS
	//ENABLE ADDRESS IN MOSI
	SET_PERI_REG_MASK(SPI_USER(HSPI), SPI_USR_ADDR);
	WRITE_PERI_REG(SPI_ADDR(HSPI), address<<(32-8));

	//SETUP 8 BIT DATA
	//ENABLE MOSI IN HSPI
	SET_PERI_REG_MASK(SPI_USER(HSPI), SPI_USR_MOSI);
	//SINCE SPI DATA REGISTER IS 32 BIT AND DATA WILL GO MSB FIRST
	//WE NEED TO SHIFT OUR 8 BIT DATA TO MSB SIDE OF W0 REGISTER
	WRITE_PERI_REG(SPI_W0(HSPI), data);

	WRITE_PERI_REG(SPI_USER1(HSPI), ((8-1)&SPI_USR_ADDR_BITLEN)<<SPI_USR_ADDR_BITLEN_S | //Number of bits in Address
										  ((8-1)&SPI_USR_MOSI_BITLEN)<<SPI_USR_MOSI_BITLEN_S | //Number of bits to Send
										  ((0-1)&SPI_USR_MISO_BITLEN)<<SPI_USR_MISO_BITLEN_S |  //Number of bits to receive
										  ((0-1)&SPI_USR_DUMMY_CYCLELEN)<<SPI_USR_DUMMY_CYCLELEN_S); //Number of Dummy bits to insert

	//NOW FINALLY SEND DATA
	ESP8266_SPI_CS_LOW;
	SET_PERI_REG_MASK(SPI_CMD(HSPI), SPI_USR);
	//WAIT FOR HSPI TO END BEFORE BRINGING CS HIGH
	while(spi_busy(HSPI));
	ESP8266_SPI_CS_HIGH;
}

void ESP8266_SPI_get(uint8_t* data)
{

}
